<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Province Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        input[type="file"], button { margin: 10px; }
        #output-section { display: flex; justify-content: center; flex-wrap: wrap; margin-top: 20px; }
        .canvas-container { margin: 10px; }
        canvas { border: 1px solid #333; max-width: 100%; }
        #console-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            max-width: 600px;
            margin: 20px auto;
            text-align: left;
            font-size: 0.9em;
            color: #333;
            height: 150px;
            overflow-y: auto;
            white-space: pre-line;
        }
    </style>
   <script src="perlin.js"></script></head>
<body>
    <h1>Binary Province Map Generator</h1>
    <p>Upload a map image to convert it to a binary water-land map.</p>
    <input type="file" id="mapInput" accept="image/*">
    <button onclick="processMap()">Generate Binary Map</button>
    <button onclick="finalizeBinary()">Finalize Binary and Create Height Map</button>
    <button onclick="const nodes = createNodalProvinceMap()">Create Nodal Province Map</button>
    <button onclick="createGeometricProvinceMap(nodes)">Create Geometric Province Map</button>



    <!-- Console Panel -->
    <div id="console-panel"></div>

    <div class="canvas-container">
        <h3>Configuration Variables</h3>
        <table style="margin: 0 auto;">
            <tr>
                <td>Blue Multiple Limit:</td>
                <td><input type="number" id="blueMultipleLimit" value="2" min="0" step="0.1"></td>
            </tr>
            <tr>
                <td>Blue Differential Limit:</td>
                <td><input type="number" id="blueDifferentialLimit" value="50" min="0"></td>
            </tr>
            <tr>
                <td>Green Bound:</td>
                <td><input type="number" id="greenBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Red Bound:</td>
                <td><input type="number" id="redBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Brightness Bound:</td>
                <td><input type="number" id="brightnessBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Mean Density:</td>
                <td><input type="number" id="meanDensity" value="10" min="1" step="1"></td>
            </tr>
        </table>
    </div>

    <div id="output-section">
        <div class="canvas-container">
            <h3>Original Map</h3>
            <canvas id="original-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Binary Map</h3>
            <canvas id="binary-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Overlay Map</h3>
            <canvas id="overlay-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Height Map</h3>
            <canvas id="height-map-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Nodal Map</h3>
            <canvas id="nodal-province-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Geoprovince Map</h3>
            <canvas id="geometric-province-canvas"></canvas>
        </div>
    </div>

    <script>
        function logToConsole(message) {
            const consolePanel = document.getElementById('console-panel');
            consolePanel.innerText += message + '\n';
            consolePanel.scrollTop = consolePanel.scrollHeight;
        }

        function processMap() {
            const fileInput = document.getElementById('mapInput');
            if (!fileInput.files.length) {
                alert("Please select a file.");
                logToConsole("Error: No file selected.");
                return;
            }

            const file = fileInput.files[0];
            const img = new Image();
            img.src = URL.createObjectURL(file);

            img.onload = () => {
                const originalCanvas = document.getElementById('original-canvas');
                const binaryCanvas = document.getElementById('binary-canvas');
                const overlayCanvas = document.getElementById('overlay-canvas');
                const heightCanvas = document.getElementById('height-map-canvas');
                const originalContext = originalCanvas.getContext('2d');
                const binaryContext = binaryCanvas.getContext('2d');
                const overlayContext = overlayCanvas.getContext('2d');
                const heightContext = heightCanvas.getContext('2d');

                originalCanvas.width = binaryCanvas.width = overlayCanvas.width = img.width;
                originalCanvas.height = binaryCanvas.height = overlayCanvas.height = img.height;

                // Draw original image
                originalContext.drawImage(img, 0, 0);

                // Create binary map and overlay
                createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, img.width, img.height);
            };
        }

        function createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, width, height) {
            const imageData = originalContext.getImageData(0, 0, width, height);
            const data = imageData.data;
            const binaryData = new Uint8ClampedArray(data);

            const blueMultipleLimit = parseFloat(document.getElementById("blueMultipleLimit").value);
            const blueDifferentialLimit = parseInt(document.getElementById("blueDifferentialLimit").value, 10);
            const greenBound = parseInt(document.getElementById("greenBound").value, 10);
            const redBound = parseInt(document.getElementById("redBound").value, 10);
            const brightnessBound = parseInt(document.getElementById("brightnessBound").value, 10);

            logToConsole(`Processing with limits: Blue Multiple ${blueMultipleLimit}, Blue Differential ${blueDifferentialLimit}, Green Bound ${greenBound}, Red Bound ${redBound}, Brightness Bound ${brightnessBound}`);
            
            // Process pixels to create binary map
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;

                // Determine if pixel is land or water based on the specified conditions
                let isLand = false;
                
                if (b >= blueMultipleLimit * Math.max(r, g)) {
                    isLand = false;
                } else if ((b - Math.max(r, g)) > blueDifferentialLimit) {
                    isLand = false;
                } else if (g > greenBound) {
                    isLand = true;
                } else if (r > redBound) {
                    isLand = true;
                } else if (brightness > brightnessBound) {
                    isLand = true;
                }

                if (isLand) {
                    // Land color (white)
                    binaryData[i] = 255; 
                    binaryData[i + 1] = 255; 
                    binaryData[i + 2] = 255;
                } else {
                    // Water color (black)
                    binaryData[i] = 0;
                    binaryData[i + 1] = 0;
                    binaryData[i + 2] = 0;
                }
            }

            // Display binary image
            const binaryImageData = new ImageData(binaryData, width, height);
            binaryContext.putImageData(binaryImageData, 0, 0);

            // Overlay binary on original with 50% opacity
            overlayContext.drawImage(originalContext.canvas, 0, 0);
            overlayContext.globalAlpha = 0.5;
            overlayContext.drawImage(binaryContext.canvas, 0, 0);
            logToConsole("Binary map and overlay map generated.");
        }

        function finalizeBinary() {
            const originalCanvas = document.getElementById('original-canvas');
            const binaryCanvas = document.getElementById('binary-canvas');
            const heightMapCanvas = document.getElementById('height-map-canvas');
            const originalContext = originalCanvas.getContext('2d');
            const binaryContext = binaryCanvas.getContext('2d');
            const heightMapContext = heightMapCanvas.getContext('2d');

            heightMapCanvas.width = binaryCanvas.width;
            heightMapCanvas.height = binaryCanvas.height;

            // Get the binary and original image data
            const binaryData = binaryContext.getImageData(0, 0, binaryCanvas.width, binaryCanvas.height).data;
            const originalData = originalContext.getImageData(0, 0, originalCanvas.width, originalCanvas.height).data;
            const heightMapData = new Uint8ClampedArray(binaryData.length);

            for (let i = 0; i < binaryData.length; i += 4) {
                const brightness = (originalData[i] + originalData[i + 1] + originalData[i + 2]) / 3;
                if (binaryData[i] === 255) { // Land
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = brightness;
                    heightMapData[i + 3] = 255; // Fully opaque
                } else { // Water
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = 0; // Black for water
                    heightMapData[i + 3] = 255;
                }
            }

            const heightMapImageData = new ImageData(heightMapData, binaryCanvas.width, binaryCanvas.height);
            heightMapContext.putImageData(heightMapImageData, 0, 0);
            logToConsole("Height map generated based on brightness and masked with binary map.");
        }

function generateNoiseMap(width, height, density, scale) {
    perlin.seed(); // Re-initialize the Perlin noise for fresh noise generation
    const noiseMap = [];

    for (let y = 0; y < height; y++) {
        noiseMap[y] = [];
        for (let x = 0; x < width; x++) {
            // Use the get method of the Perlin noise object and invert the value
            const noiseValue = (1 - (perlin.get(x / scale, y / scale) + 1) / 2); // Invert to make peaks dark
            noiseMap[y][x] = noiseValue;  // Keep value between 0 (dark) and 1 (light)
        }
    }
    return noiseMap;
}


    let nodes = [];
        
     // Function to create nodes across the entire land area
function createNodalProvinceMap() {
    const heightMapCanvas = document.getElementById('height-map-canvas');
    const heightMapContext = heightMapCanvas.getContext('2d');
    const nodalCanvas = document.getElementById('nodal-province-canvas');
    const nodalContext = nodalCanvas.getContext('2d');

    const width = heightMapCanvas.width;
    const height = heightMapCanvas.height;
    const density = parseInt(document.getElementById("meanDensity").value, 10);
    const heightData = heightMapContext.getImageData(0, 0, width, height).data;
    const noiseMap = generateNoiseMap(width, height, density, 50); // Adjust scale as needed

    // Define a combined map based on height and noise
    const combinedMap = [];
    for (let y = 0; y < height; y++) {
        combinedMap[y] = [];
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const brightness = heightData[index]; // Brightness for height
            const noiseValue = noiseMap[y][x]; // Noise value at (x, y)

            // Combine height and noise; high brightness and low noise values are less favorable for nodes
            combinedMap[y][x] = (1 - noiseValue) * (1 - brightness / 255); // Scale both height and noise
        }
    }

    nodalCanvas.width = width;
    nodalCanvas.height = height;
    nodalContext.clearRect(0, 0, width, height);
    nodalContext.drawImage(heightMapCanvas, 0, 0); // Background for height map reference

    const nodes = [];
    const minDistance = Math.max(10, 30 / density); // Minimum distance between nodes

for (let y = 0; y < height; y += Math.floor(Math.random() * 10 + 5)) {
    for (let x = 0; x < width; x += Math.floor(Math.random() * 10 + 5)) {

        const index = (y * width + x) * 4;
        const brightness = heightData[index]; // Brightness for height
        const noiseValue = noiseMap[y][x]; // Noise value at (x, y)
        
        // Skip water areas based on brightness threshold
        if (brightness < 20) continue; // Water areas

        // Push nodes away from high-altitude areas (very bright regions)
       if (brightness > 200) { // Altitude threshold
            x += Math.random() * 5 - 2.5; // Random x offset
            y += Math.random() * 5 - 2.5; // Random y offset
            x = Math.max(0, Math.min(x, width - 1));
            y = Math.max(0, Math.min(y, height - 1));
            const newIndex = (Math.round(y) * width + Math.round(x)) * 4;
            const newBrightness = heightData[newIndex];
            if (newBrightness < 30) continue; // Skip if the shifted position is on water
        }

        const combinedValue = (1 - noiseValue) * (1 - brightness / 255);
        const placementChance = Math.random();

        if (combinedValue > 0.2 && combinedValue < 0.7 && placementChance < 0.3) { 
            let isFarEnough = true;
            for (let i = 0; i < nodes.length; i++) {
                const dx = nodes[i].x - x;
                const dy = nodes[i].y - y;
                if (dx * dx + dy * dy < minDistance * minDistance) {
                    isFarEnough = false;
                    break;
                }
            }
            if (isFarEnough) {
                nodes.push({ x, y });
                nodalContext.fillStyle = 'red';
                nodalContext.fillRect(x, y, 2, 2);
            }
        }
    }
}

    console.log(`Nodal province map created with ${nodes.length} nodes over the full map.`);
    return nodes; // Nodes for province generation
}





// Function to create geometric provinces using Voronoi-like diagram
function createGeometricProvinceMap(nodes) {
    const heightMapCanvas = document.getElementById('height-map-canvas');
    const geometricCanvas = document.getElementById('geometric-province-canvas');
    const geometricContext = geometricCanvas.getContext('2d');
    
    const provinceColors = ["#A3D9A5", "#E1D89F", "#B3A9D4", "#DFB6C0"];
    const heightData = heightMapCanvas.getContext('2d').getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height).data;

    // Clear and prepare the geometric canvas
    geometricContext.clearRect(0, 0, geometricCanvas.width, geometricCanvas.height);

    // Iterate over each node and create a province based on Voronoi-like fill
    nodes.forEach((node, index) => {
        const provinceColor = provinceColors[index % provinceColors.length];
        geometricContext.fillStyle = provinceColor;
        fillProvince(node, provinceColor, heightData, heightMapCanvas.width, heightMapCanvas.height, geometricContext);
    });

    console.log("Geometric province map created.");
}

// Helper function for filling provinces from each node
function fillProvince(node, color, heightData, width, height, context) {
    const queue = [node];
    const visited = new Set([`${node.x},${node.y}`]);

    while (queue.length > 0) {
        const { x, y } = queue.shift();
        const index = (y * width + x) * 4;

        // Check if it’s land and color it
        if (heightData[index] > 0) {
            context.fillStyle = color;
            context.fillRect(x, y, 1, 1);

            // Check neighbors for filling
            [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const nIndex = (ny * width + nx) * 4;
                    const key = `${nx},${ny}`;
                    if (heightData[nIndex] > 0 && !visited.has(key)) { // Only add unvisited land
                        queue.push({ x: nx, y: ny });
                        visited.add(key);
                    }
                }
            });
        }
    }
}
    </script>
</body>
</html>
