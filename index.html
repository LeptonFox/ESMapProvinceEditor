<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Province Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        input[type="file"], button { margin: 10px; }
        #output-section { display: flex; justify-content: center; flex-wrap: wrap; margin-top: 20px; }
        .canvas-container { margin: 10px; }
        canvas { border: 1px solid #333; max-width: 100%; }
        #console-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            max-width: 600px;
            margin: 20px auto;
            text-align: left;
            font-size: 0.9em;
            color: #333;
            height: 150px;
            overflow-y: auto;
            white-space: pre-line;
        }
    </style>
</head>
<body>
    <h1>Binary Province Map Generator</h1>
    <p>Upload a map image to convert it to a binary water-land map.</p>
    <input type="file" id="mapInput" accept="image/*">
    <button onclick="processMap()">Generate Binary Map</button>
    <button onclick="finalizeBinary()">Finalize Binary and Create Height Map</button>
    <button onclick="const nodes = createNodalProvinceMap()">Create Nodal Province Map</button>
    <button onclick="createGeometricProvinceMap(nodes)">Create Geometric Province Map</button>



    <!-- Console Panel -->
    <div id="console-panel"></div>

    <div class="canvas-container">
        <h3>Configuration Variables</h3>
        <table style="margin: 0 auto;">
            <tr>
                <td>Blue Multiple Limit:</td>
                <td><input type="number" id="blueMultipleLimit" value="2" min="0" step="0.1"></td>
            </tr>
            <tr>
                <td>Blue Differential Limit:</td>
                <td><input type="number" id="blueDifferentialLimit" value="50" min="0"></td>
            </tr>
            <tr>
                <td>Green Bound:</td>
                <td><input type="number" id="greenBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Red Bound:</td>
                <td><input type="number" id="redBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Brightness Bound:</td>
                <td><input type="number" id="brightnessBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Mean Density:</td>
                <td><input type="number" id="meanDensity" value="10" min="1" step="1"></td>
            </tr>

        </table>
    </div>

    <div id="output-section">
        <div class="canvas-container">
            <h3>Original Map</h3>
            <canvas id="original-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Binary Map</h3>
            <canvas id="binary-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Overlay Map</h3>
            <canvas id="overlay-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Height Map</h3>
            <canvas id="height-map-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Nodal Map</h3>
            <canvas id="nodal-province-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Geoprovince Map</h3>
            <canvas id="geometric-province-canvas"></canvas>
        </div>
    </div>

    <script>
        function logToConsole(message) {
            const consolePanel = document.getElementById('console-panel');
            consolePanel.innerText += message + '\n';
            consolePanel.scrollTop = consolePanel.scrollHeight;
        }

        function processMap() {
            const fileInput = document.getElementById('mapInput');
            if (!fileInput.files.length) {
                alert("Please select a file.");
                logToConsole("Error: No file selected.");
                return;
            }

            const file = fileInput.files[0];
            const img = new Image();
            img.src = URL.createObjectURL(file);

            img.onload = () => {
                const originalCanvas = document.getElementById('original-canvas');
                const binaryCanvas = document.getElementById('binary-canvas');
                const overlayCanvas = document.getElementById('overlay-canvas');
                const originalContext = originalCanvas.getContext('2d');
                const binaryContext = binaryCanvas.getContext('2d');
                const overlayContext = overlayCanvas.getContext('2d');

                originalCanvas.width = binaryCanvas.width = overlayCanvas.width = img.width;
                originalCanvas.height = binaryCanvas.height = overlayCanvas.height = img.height;

                // Draw original image
                originalContext.drawImage(img, 0, 0);

                // Create binary map and overlay
                createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, img.width, img.height);
            };
        }

        function createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, width, height) {
            const imageData = originalContext.getImageData(0, 0, width, height);
            const data = imageData.data;
            const binaryData = new Uint8ClampedArray(data);

            const blueMultipleLimit = parseFloat(document.getElementById("blueMultipleLimit").value);
            const blueDifferentialLimit = parseInt(document.getElementById("blueDifferentialLimit").value, 10);
            const greenBound = parseInt(document.getElementById("greenBound").value, 10);
            const redBound = parseInt(document.getElementById("redBound").value, 10);
            const brightnessBound = parseInt(document.getElementById("brightnessBound").value, 10);

            logToConsole(`Processing with limits: Blue Multiple ${blueMultipleLimit}, Blue Differential ${blueDifferentialLimit}, Green Bound ${greenBound}, Red Bound ${redBound}, Brightness Bound ${brightnessBound}`);
            
            // Process pixels to create binary map
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;

                // Determine if pixel is land or water based on the specified conditions
                let isLand = false;
                
                if (b >= blueMultipleLimit * Math.max(r, g)) {
                    isLand = false;
                } else if ((b - Math.max(r, g)) > blueDifferentialLimit) {
                    isLand = false;
                } else if (g > greenBound) {
                    isLand = true;
                } else if (r > redBound) {
                    isLand = true;
                } else if (brightness > brightnessBound) {
                    isLand = true;
                }

                if (isLand) {
                    // Land color (white)
                    binaryData[i] = 255; 
                    binaryData[i + 1] = 255; 
                    binaryData[i + 2] = 255;
                } else {
                    // Water color (black)
                    binaryData[i] = 0;
                    binaryData[i + 1] = 0;
                    binaryData[i + 2] = 0;
                }
            }

            // Display binary image
            const binaryImageData = new ImageData(binaryData, width, height);
            binaryContext.putImageData(binaryImageData, 0, 0);

            // Overlay binary on original with 50% opacity
            overlayContext.drawImage(originalContext.canvas, 0, 0);
            overlayContext.globalAlpha = 0.5;
            overlayContext.drawImage(binaryContext.canvas, 0, 0);
            logToConsole("Binary map and overlay map generated.");
        }

        function finalizeBinary() {
            const originalCanvas = document.getElementById('original-canvas');
            const binaryCanvas = document.getElementById('binary-canvas');
            const heightMapCanvas = document.getElementById('height-map-canvas');
            const originalContext = originalCanvas.getContext('2d');
            const binaryContext = binaryCanvas.getContext('2d');
            const heightMapContext = heightMapCanvas.getContext('2d');

            heightMapCanvas.width = binaryCanvas.width;
            heightMapCanvas.height = binaryCanvas.height;

            // Get the binary and original image data
            const binaryData = binaryContext.getImageData(0, 0, binaryCanvas.width, binaryCanvas.height).data;
            const originalData = originalContext.getImageData(0, 0, originalCanvas.width, originalCanvas.height).data;
            const heightMapData = new Uint8ClampedArray(binaryData.length);

            for (let i = 0; i < binaryData.length; i += 4) {
                const brightness = (originalData[i] + originalData[i + 1] + originalData[i + 2]) / 3;
                if (binaryData[i] === 255) { // Land
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = brightness;
                    heightMapData[i + 3] = 255; // Fully opaque
                } else { // Water
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = 0; // Black for water
                    heightMapData[i + 3] = 255;
                }
            }

            const heightMapImageData = new ImageData(heightMapData, binaryCanvas.width, binaryCanvas.height);
            heightMapContext.putImageData(heightMapImageData, 0, 0);
            logToConsole("Height map generated based on brightness and masked with binary map.");
        }

        function generateNoiseMap(width, height, density, scale) {
    const noiseMap = [];
    for (let y = 0; y < height; y++) {
        noiseMap[y] = [];
        for (let x = 0; x < width; x++) {
            // Basic random noise generation
            const randomValue = Math.random() * density;
            noiseMap[y][x] = randomValue / scale; // Scale the noise
        }
    }
    return noiseMap;
}

    let nodes = [];
        
      function createNodalProvinceMap() {
    const heightMapCanvas = document.getElementById('height-map-canvas');
    const heightMapContext = heightMapCanvas.getContext('2d');
    const nodalCanvas = document.getElementById('nodal-province-canvas');
    const nodalContext = nodalCanvas.getContext('2d');
    
    const density = parseInt(document.getElementById("meanDensity").value, 10); // Node density control
    const noiseMap = generateNoiseMap(heightMapCanvas.width, heightMapCanvas.height, density, 50); // High-detail noise map
    const heightData = heightMapContext.getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height).data;
    
    nodalContext.drawImage(heightMapCanvas, 0, 0); // Start with the height map

    // Overlay nodes based on noise peaks in land areas
    const nodes = [];
    for (let y = 0; y < heightMapCanvas.height; y++) {
        for (let x = 0; x < heightMapCanvas.width; x++) {
            const index = (y * heightMapCanvas.width + x) * 4;
            const brightness = heightData[index];
            
            // Check if it's a land pixel and high in both height and noise (peak-like)
            if (brightness > 0 && noiseMap[y][x] > 0.6) { // Threshold for peaks in noise
                nodes.push({ x, y });
                nodalContext.fillStyle = 'red'; // Mark nodes in red
                nodalContext.fillRect(x, y, 2, 2); // Draw node point
            }
        }
    }
    
    logToConsole(`Nodal province map created with ${nodes.length} nodes.`);
    return nodes; // Return nodes for use in geometric province generation
}

        function createGeometricProvinceMap(nodes) {
    const heightMapCanvas = document.getElementById('height-map-canvas');
    const geometricCanvas = document.getElementById('geometric-province-canvas');
    geometricCanvas.width = heightMapCanvas.width;
    geometricCanvas.height = heightMapCanvas.height;
    const geometricContext = geometricCanvas.getContext('2d');
    
    // Colors for provinces
    const provinceColors = ["#A3D9A5", "#E1D89F", "#B3A9D4", "#DFB6C0"];
    const heightData = heightMapCanvas.getContext('2d').getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height).data;

    // Use a Voronoi-like approach for associating each pixel to the nearest node
    nodes.forEach((node, index) => {
        const provinceColor = provinceColors[index % provinceColors.length];
        geometricContext.fillStyle = provinceColor;
        fillProvince(node, provinceColor, heightData, heightMapCanvas.width, heightMapCanvas.height, geometricContext);
    });

    document.body.appendChild(geometricCanvas); // Display the geometric province map canvas
    logToConsole("Geometric province map created.");
}

// Helper function to "fill" provinces based on node proximity (simplified Voronoi approach)
function fillProvince(node, color, heightData, width, height, context) {
    const queue = [node];
    const visited = new Set([`${node.x},${node.y}`]);

    while (queue.length > 0) {
        const { x, y } = queue.shift();
        const index = (y * width + x) * 4;

        // If itâ€™s land, color it as part of the province
        if (heightData[index] > 0) {
            context.fillStyle = color;
            context.fillRect(x, y, 1, 1);

            // Check neighbors in four directions
            [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dx, dy]) => {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const nIndex = (ny * width + nx) * 4;
                    const key = `${nx},${ny}`;
                    if (heightData[nIndex] > 0 && !visited.has(key)) { // Land and unvisited
                        queue.push({ x: nx, y: ny });
                        visited.add(key);
                    }
                }
            });
        }
    }
}

    </script>
</body>
</html>
