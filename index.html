<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Province Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        input[type="file"], button { margin: 10px; }
        #output-section { display: flex; justify-content: center; flex-wrap: wrap; margin-top: 20px; }
        .canvas-container { margin: 10px; }
        canvas { border: 1px solid #333; max-width: 100%; }
        #console-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            max-width: 600px;
            margin: 20px auto;
            text-align: left;
            font-size: 0.9em;
            color: #333;
            height: 150px;
            overflow-y: auto;
            white-space: pre-line;
        }
    </style>
</head>
<body>
    <h1>Binary Province Map Generator</h1>
    <p>Upload a map image to convert it to a binary water-land map.</p>
    <input type="file" id="mapInput" accept="image/*">
    <button onclick="processMap()">Generate Binary Map</button>
    <button onclick="finalizeBinary()">Finalize Binary and Create Height Map</button>
    <button onclick="createGeometry()">Create Geometry</button>


    <!-- Console Panel -->
    <div id="console-panel"></div>

    <div class="canvas-container">
        <h3>Configuration Variables</h3>
        <table style="margin: 0 auto;">
            <tr>
                <td>Blue Multiple Limit:</td>
                <td><input type="number" id="blueMultipleLimit" value="2" min="0" step="0.1"></td>
            </tr>
            <tr>
                <td>Blue Differential Limit:</td>
                <td><input type="number" id="blueDifferentialLimit" value="50" min="0"></td>
            </tr>
            <tr>
                <td>Green Bound:</td>
                <td><input type="number" id="greenBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Red Bound:</td>
                <td><input type="number" id="redBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Brightness Bound:</td>
                <td><input type="number" id="brightnessBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Mean Density:</td>
                <td><input type="number" id="meanDensity" value="10" min="1" step="1"></td>
            </tr>

        </table>
    </div>

    <div id="output-section">
        <div class="canvas-container">
            <h3>Original Map</h3>
            <canvas id="original-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Binary Map</h3>
            <canvas id="binary-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Overlay Map</h3>
            <canvas id="overlay-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Height Map</h3>
            <canvas id="height-map-canvas"></canvas>
        </div>
    </div>

    <script>
        function logToConsole(message) {
            const consolePanel = document.getElementById('console-panel');
            consolePanel.innerText += message + '\n';
            consolePanel.scrollTop = consolePanel.scrollHeight;
        }

        function processMap() {
            const fileInput = document.getElementById('mapInput');
            if (!fileInput.files.length) {
                alert("Please select a file.");
                logToConsole("Error: No file selected.");
                return;
            }

            const file = fileInput.files[0];
            const img = new Image();
            img.src = URL.createObjectURL(file);

            img.onload = () => {
                const originalCanvas = document.getElementById('original-canvas');
                const binaryCanvas = document.getElementById('binary-canvas');
                const overlayCanvas = document.getElementById('overlay-canvas');
                const originalContext = originalCanvas.getContext('2d');
                const binaryContext = binaryCanvas.getContext('2d');
                const overlayContext = overlayCanvas.getContext('2d');

                originalCanvas.width = binaryCanvas.width = overlayCanvas.width = img.width;
                originalCanvas.height = binaryCanvas.height = overlayCanvas.height = img.height;

                // Draw original image
                originalContext.drawImage(img, 0, 0);

                // Create binary map and overlay
                createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, img.width, img.height);
            };
        }

        function createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, width, height) {
            const imageData = originalContext.getImageData(0, 0, width, height);
            const data = imageData.data;
            const binaryData = new Uint8ClampedArray(data);

            const blueMultipleLimit = parseFloat(document.getElementById("blueMultipleLimit").value);
            const blueDifferentialLimit = parseInt(document.getElementById("blueDifferentialLimit").value, 10);
            const greenBound = parseInt(document.getElementById("greenBound").value, 10);
            const redBound = parseInt(document.getElementById("redBound").value, 10);
            const brightnessBound = parseInt(document.getElementById("brightnessBound").value, 10);

            logToConsole(`Processing with limits: Blue Multiple ${blueMultipleLimit}, Blue Differential ${blueDifferentialLimit}, Green Bound ${greenBound}, Red Bound ${redBound}, Brightness Bound ${brightnessBound}`);
            
            // Process pixels to create binary map
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;

                // Determine if pixel is land or water based on the specified conditions
                let isLand = false;
                
                if (b >= blueMultipleLimit * Math.max(r, g)) {
                    isLand = false;
                } else if ((b - Math.max(r, g)) > blueDifferentialLimit) {
                    isLand = false;
                } else if (g > greenBound) {
                    isLand = true;
                } else if (r > redBound) {
                    isLand = true;
                } else if (brightness > brightnessBound) {
                    isLand = true;
                }

                if (isLand) {
                    // Land color (white)
                    binaryData[i] = 255; 
                    binaryData[i + 1] = 255; 
                    binaryData[i + 2] = 255;
                } else {
                    // Water color (black)
                    binaryData[i] = 0;
                    binaryData[i + 1] = 0;
                    binaryData[i + 2] = 0;
                }
            }

            // Display binary image
            const binaryImageData = new ImageData(binaryData, width, height);
            binaryContext.putImageData(binaryImageData, 0, 0);

            // Overlay binary on original with 50% opacity
            overlayContext.drawImage(originalContext.canvas, 0, 0);
            overlayContext.globalAlpha = 0.5;
            overlayContext.drawImage(binaryContext.canvas, 0, 0);
            logToConsole("Binary map and overlay map generated.");
        }

        function finalizeBinary() {
            const originalCanvas = document.getElementById('original-canvas');
            const binaryCanvas = document.getElementById('binary-canvas');
            const heightMapCanvas = document.getElementById('height-map-canvas');
            const originalContext = originalCanvas.getContext('2d');
            const binaryContext = binaryCanvas.getContext('2d');
            const heightMapContext = heightMapCanvas.getContext('2d');

            heightMapCanvas.width = binaryCanvas.width;
            heightMapCanvas.height = binaryCanvas.height;

            // Get the binary and original image data
            const binaryData = binaryContext.getImageData(0, 0, binaryCanvas.width, binaryCanvas.height).data;
            const originalData = originalContext.getImageData(0, 0, originalCanvas.width, originalCanvas.height).data;
            const heightMapData = new Uint8ClampedArray(binaryData.length);

            for (let i = 0; i < binaryData.length; i += 4) {
                const brightness = (originalData[i] + originalData[i + 1] + originalData[i + 2]) / 3;
                if (binaryData[i] === 255) { // Land
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = brightness;
                    heightMapData[i + 3] = 255; // Fully opaque
                } else { // Water
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = 0; // Black for water
                    heightMapData[i + 3] = 255;
                }
            }

            const heightMapImageData = new ImageData(heightMapData, binaryCanvas.width, binaryCanvas.height);
            heightMapContext.putImageData(heightMapImageData, 0, 0);
            logToConsole("Height map generated based on brightness and masked with binary map.");
        }

        function createGeometry() {
    const heightMapCanvas = document.getElementById('height-map-canvas');
    const heightMapContext = heightMapCanvas.getContext('2d');
    const heightData = heightMapContext.getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height).data;

    const meanDensity = parseInt(document.getElementById("meanDensity").value, 10);
    logToConsole(`Creating geometry with mean density: ${meanDensity}`);

    const polygons = []; // Store resulting provinces' polygons

    // Loop through pixels to define "elevation regions"
    for (let y = 0; y < heightMapCanvas.height; y += meanDensity) {
        for (let x = 0; x < heightMapCanvas.width; x += meanDensity) {
            const index = (y * heightMapCanvas.width + x) * 4;
            const brightness = heightData[index]; // Height at (x, y)

            // Determine density based on elevation (higher -> larger provinces)
            const density = meanDensity + (brightness > 128 ? -2 : 2);

            // Only sample within this density
            const region = [];
            for (let dy = 0; dy < density; dy++) {
                for (let dx = 0; dx < density; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx < heightMapCanvas.width && ny < heightMapCanvas.height) {
                        const nIndex = (ny * heightMapCanvas.width + nx) * 4;
                        if (heightData[nIndex] > 0) { // Non-water
                            region.push([nx, ny]);
                        }
                    }
                }
            }

            // Approximate the region with a polygon using convex hull (or other simplifications)
            if (region.length > 0) {
                const simplifiedPolygon = approximatePolygon(region);
                polygons.push(simplifiedPolygon);
            }
        }
    }

    drawPolygons(polygons);
    logToConsole(`Geometry created with ${polygons.length} provinces.`);
}

function approximatePolygon(points) {
    // Basic polygon approximation logic, replace with a convex hull or other method as needed
    // For now, we return the original points as an example
    return points;
}

function drawPolygons(polygons) {
    const overlayCanvas = document.getElementById('overlay-canvas');
    const overlayContext = overlayCanvas.getContext('2d');

    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    polygons.forEach(polygon => {
        overlayContext.beginPath();
        polygon.forEach(([x, y], index) => {
            if (index === 0) {
                overlayContext.moveTo(x, y);
            } else {
                overlayContext.lineTo(x, y);
            }
        });
        overlayContext.closePath();
        overlayContext.strokeStyle = `rgba(0, 128, 0, 0.5)`; // Light green for visualization
        overlayContext.stroke();
    });
}

    </script>
</body>
</html>
