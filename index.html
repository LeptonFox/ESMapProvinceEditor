<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Province Map Generator</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        input[type="file"], button { margin: 10px; }
        #output-section { display: flex; justify-content: center; flex-wrap: wrap; margin-top: 20px; }
        .canvas-container { margin: 10px; }
        canvas { border: 1px solid #333; max-width: 100%; }
        #console-panel {
            margin-top: 20px;
            padding: 10px;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
            max-width: 600px;
            margin: 20px auto;
            text-align: left;
            font-size: 0.9em;
            color: #333;
            height: 150px;
            overflow-y: auto;
            white-space: pre-line;
        }
    </style>
</head>
<body>
    <h1>Binary Province Map Generator</h1>
    <p>Upload a map image to convert it to a binary water-land map.</p>
    <input type="file" id="mapInput" accept="image/*">
    <button onclick="processMap()">Generate Binary Map</button>
    <button onclick="finalizeBinary()">Finalize Binary and Create Height Map</button>
    <button onclick="createComplexProvinces()">Create Complex Provinces</button>


    <!-- Console Panel -->
    <div id="console-panel"></div>

    <div class="canvas-container">
        <h3>Configuration Variables</h3>
        <table style="margin: 0 auto;">
            <tr>
                <td>Blue Multiple Limit:</td>
                <td><input type="number" id="blueMultipleLimit" value="2" min="0" step="0.1"></td>
            </tr>
            <tr>
                <td>Blue Differential Limit:</td>
                <td><input type="number" id="blueDifferentialLimit" value="50" min="0"></td>
            </tr>
            <tr>
                <td>Green Bound:</td>
                <td><input type="number" id="greenBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Red Bound:</td>
                <td><input type="number" id="redBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Brightness Bound:</td>
                <td><input type="number" id="brightnessBound" value="150" min="0" max="255"></td>
            </tr>
            <tr>
                <td>Mean Density:</td>
                <td><input type="number" id="meanDensity" value="10" min="1" step="1"></td>
            </tr>

        </table>
    </div>

    <div id="output-section">
        <div class="canvas-container">
            <h3>Original Map</h3>
            <canvas id="original-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Binary Map</h3>
            <canvas id="binary-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Overlay Map</h3>
            <canvas id="overlay-canvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Height Map</h3>
            <canvas id="height-map-canvas"></canvas>
        </div>
    </div>

    <script>
        function logToConsole(message) {
            const consolePanel = document.getElementById('console-panel');
            consolePanel.innerText += message + '\n';
            consolePanel.scrollTop = consolePanel.scrollHeight;
        }

        function processMap() {
            const fileInput = document.getElementById('mapInput');
            if (!fileInput.files.length) {
                alert("Please select a file.");
                logToConsole("Error: No file selected.");
                return;
            }

            const file = fileInput.files[0];
            const img = new Image();
            img.src = URL.createObjectURL(file);

            img.onload = () => {
                const originalCanvas = document.getElementById('original-canvas');
                const binaryCanvas = document.getElementById('binary-canvas');
                const overlayCanvas = document.getElementById('overlay-canvas');
                const originalContext = originalCanvas.getContext('2d');
                const binaryContext = binaryCanvas.getContext('2d');
                const overlayContext = overlayCanvas.getContext('2d');

                originalCanvas.width = binaryCanvas.width = overlayCanvas.width = img.width;
                originalCanvas.height = binaryCanvas.height = overlayCanvas.height = img.height;

                // Draw original image
                originalContext.drawImage(img, 0, 0);

                // Create binary map and overlay
                createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, img.width, img.height);
            };
        }

        function createBinaryAndOverlayMap(originalContext, binaryContext, overlayContext, width, height) {
            const imageData = originalContext.getImageData(0, 0, width, height);
            const data = imageData.data;
            const binaryData = new Uint8ClampedArray(data);

            const blueMultipleLimit = parseFloat(document.getElementById("blueMultipleLimit").value);
            const blueDifferentialLimit = parseInt(document.getElementById("blueDifferentialLimit").value, 10);
            const greenBound = parseInt(document.getElementById("greenBound").value, 10);
            const redBound = parseInt(document.getElementById("redBound").value, 10);
            const brightnessBound = parseInt(document.getElementById("brightnessBound").value, 10);

            logToConsole(`Processing with limits: Blue Multiple ${blueMultipleLimit}, Blue Differential ${blueDifferentialLimit}, Green Bound ${greenBound}, Red Bound ${redBound}, Brightness Bound ${brightnessBound}`);
            
            // Process pixels to create binary map
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;

                // Determine if pixel is land or water based on the specified conditions
                let isLand = false;
                
                if (b >= blueMultipleLimit * Math.max(r, g)) {
                    isLand = false;
                } else if ((b - Math.max(r, g)) > blueDifferentialLimit) {
                    isLand = false;
                } else if (g > greenBound) {
                    isLand = true;
                } else if (r > redBound) {
                    isLand = true;
                } else if (brightness > brightnessBound) {
                    isLand = true;
                }

                if (isLand) {
                    // Land color (white)
                    binaryData[i] = 255; 
                    binaryData[i + 1] = 255; 
                    binaryData[i + 2] = 255;
                } else {
                    // Water color (black)
                    binaryData[i] = 0;
                    binaryData[i + 1] = 0;
                    binaryData[i + 2] = 0;
                }
            }

            // Display binary image
            const binaryImageData = new ImageData(binaryData, width, height);
            binaryContext.putImageData(binaryImageData, 0, 0);

            // Overlay binary on original with 50% opacity
            overlayContext.drawImage(originalContext.canvas, 0, 0);
            overlayContext.globalAlpha = 0.5;
            overlayContext.drawImage(binaryContext.canvas, 0, 0);
            logToConsole("Binary map and overlay map generated.");
        }

        function finalizeBinary() {
            const originalCanvas = document.getElementById('original-canvas');
            const binaryCanvas = document.getElementById('binary-canvas');
            const heightMapCanvas = document.getElementById('height-map-canvas');
            const originalContext = originalCanvas.getContext('2d');
            const binaryContext = binaryCanvas.getContext('2d');
            const heightMapContext = heightMapCanvas.getContext('2d');

            heightMapCanvas.width = binaryCanvas.width;
            heightMapCanvas.height = binaryCanvas.height;

            // Get the binary and original image data
            const binaryData = binaryContext.getImageData(0, 0, binaryCanvas.width, binaryCanvas.height).data;
            const originalData = originalContext.getImageData(0, 0, originalCanvas.width, originalCanvas.height).data;
            const heightMapData = new Uint8ClampedArray(binaryData.length);

            for (let i = 0; i < binaryData.length; i += 4) {
                const brightness = (originalData[i] + originalData[i + 1] + originalData[i + 2]) / 3;
                if (binaryData[i] === 255) { // Land
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = brightness;
                    heightMapData[i + 3] = 255; // Fully opaque
                } else { // Water
                    heightMapData[i] = heightMapData[i + 1] = heightMapData[i + 2] = 0; // Black for water
                    heightMapData[i + 3] = 255;
                }
            }

            const heightMapImageData = new ImageData(heightMapData, binaryCanvas.width, binaryCanvas.height);
            heightMapContext.putImageData(heightMapImageData, 0, 0);
            logToConsole("Height map generated based on brightness and masked with binary map.");
        }

        function createComplexProvinces() {
    const heightMapCanvas = document.getElementById('height-map-canvas');
    const heightMapContext = heightMapCanvas.getContext('2d');
    const overlayCanvas = document.getElementById('overlay-canvas');
    const overlayContext = overlayCanvas.getContext('2d');

    const density = parseInt(document.getElementById("meanDensity").value, 10); // Nodes per 50x50 pixels
    const gridResolution = 50; // Size of grid cells for density scaling
    const colors = ["#A3D9A5", "#E1D89F", "#B3A9D4", "#DFB6C0"]; // Four colors for province differentiation

    const heightData = heightMapContext.getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height).data;
    const noiseMap = generateNoiseMap(heightMapCanvas.width, heightMapCanvas.height, density, gridResolution);
    const provinceRegions = {}; // To store province regions by color

    // Loop through each pixel, assigning provinces based on noise map
    for (let y = 0; y < heightMapCanvas.height; y++) {
        for (let x = 0; x < heightMapCanvas.width; x++) {
            const index = (y * heightMapCanvas.width + x) * 4;

            if (heightData[index] > 0) { // Land pixel
                const noiseValue = noiseMap[y][x];
                const color = colors[Math.floor(noiseValue * colors.length) % colors.length];

                if (!provinceRegions[color]) {
                    provinceRegions[color] = [];
                }
                provinceRegions[color].push([x, y]);
            }
        }
    }

    // Draw provinces on overlay canvas
    overlayContext.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    Object.keys(provinceRegions).forEach((color, index) => {
        overlayContext.fillStyle = color;
        overlayContext.beginPath();

        // Draw each point in the province as a continuous path
        provinceRegions[color].forEach(([x, y], idx) => {
            if (idx === 0) overlayContext.moveTo(x, y);
            else overlayContext.lineTo(x, y);
        });

        overlayContext.closePath();
        overlayContext.fill();
    });
    logToConsole(`Complex provinces created using noise with ${density} nodes per ${gridResolution}x${gridResolution} area.`);
}

// Helper function to generate noise map (use Perlin or Simplex noise)
function generateNoiseMap(width, height, density, gridResolution) {
    const noiseMap = Array.from(Array(height), () => Array(width).fill(0));

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            // Noise generation
            const noiseValue = (Math.sin((x + y) * density / gridResolution) + 1) / 2;
            noiseMap[y][x] = noiseValue;
        }
    }
    return noiseMap;
}

    </script>
</body>
</html>
